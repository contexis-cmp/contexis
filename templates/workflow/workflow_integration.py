#!/usr/bin/env python3
"""
Workflow Integration Test: {{ .Name }}
Generated by CMP Framework on {{ .CreatedDate }}
"""

import sys
import os
import json
import yaml
import pytest
from pathlib import Path
from typing import Dict, List, Any

# Add workflow to path
sys.path.append(os.path.join(os.path.dirname(__file__), '../../workflows/{{ .Name }}'))

class {{ .Name }}WorkflowTest:
    """Integration tests for {{ .Name }} workflow"""
    
    def __init__(self):
        self.workflow_name = "{{ .Name }}"
        self.workflow_path = Path(__file__).parent.parent.parent / "workflows" / "{{ .Name }}"
        self.config = self.load_workflow_config()
        
    def load_workflow_config(self) -> Dict[str, Any]:
        """Load workflow configuration"""
        config_path = self.workflow_path / f"{self.workflow_name}.yaml"
        with open(config_path, 'r') as f:
            return yaml.safe_load(f)
    
    def test_workflow_structure(self):
        """Test workflow structure and configuration"""
        assert self.config['name'] == self.workflow_name
        assert 'steps' in self.config
        assert 'config' in self.config
        assert 'resources' in self.config
        
        # Test steps configuration
        steps = self.config['steps']
        assert len(steps) == {{ len .StepsConfig }}
        
        for step in steps:
            assert 'name' in step
            assert 'type' in step
            assert 'timeout' in step
            assert 'retry_attempts' in step
    
    def test_step_dependencies(self):
        """Test step dependency resolution"""
        steps = self.config['steps']
        
        for i, step in enumerate(steps):
            if i > 0:
                # Check that dependencies are properly set
                assert 'dependencies' in step
                if step['dependencies']:
                    for dep in step['dependencies']:
                        # Verify dependency exists
                        dep_exists = any(s['name'] == dep for s in steps)
                        assert dep_exists, f"Dependency {dep} for step {step['name']} does not exist"
    
    def test_resource_limits(self):
        """Test resource limits configuration"""
        resources = self.config['resources']
        
        assert 'cpu' in resources
        assert 'memory' in resources
        assert 'storage' in resources
        assert 'network' in resources
        
        # Validate resource values
        assert resources['cpu'] == "{{ .ResourceLimits.CPU }}"
        assert resources['memory'] == "{{ .ResourceLimits.Memory }}"
        assert resources['storage'] == "{{ .ResourceLimits.Storage }}"
        assert resources['network'] == "{{ .ResourceLimits.Network }}"
    
    def test_error_handling(self):
        """Test error handling configuration"""
        config = self.config['config']
        
        assert 'error_handling' in config
        assert 'retry_attempts' in config
        assert 'retry_delay' in config
        
        assert config['error_handling'] == "{{ .ErrorHandling }}"
        assert config['retry_attempts'] == {{ .RetryAttempts }}
        assert config['retry_delay'] == {{ .RetryDelay }}
    
    def test_state_persistence(self):
        """Test state persistence configuration"""
        config = self.config['config']
        
        assert 'state_persistence' in config
        assert config['state_persistence'] == {{ .StatePersistence }}
    
    def test_workflow_files_exist(self):
        """Test that all workflow files exist"""
        required_files = [
            f"workflows/{self.workflow_name}/{self.workflow_name}.yaml",
            f"contexts/{self.workflow_name}/workflow_coordinator.ctx",
            f"memory/{self.workflow_name}/workflow_state.yaml",
        ]
        
        for file_path in required_files:
            full_path = Path(__file__).parent.parent.parent / file_path
            assert full_path.exists(), f"Required file {file_path} does not exist"
    
    def test_step_templates_exist(self):
        """Test that step templates exist"""
        steps = self.config['steps']
        
        for step in steps:
            template_path = Path(__file__).parent.parent.parent / f"prompts/{self.workflow_name}/step_templates/{step['name']}.md"
            assert template_path.exists(), f"Step template {step['name']}.md does not exist"
    
    def test_workflow_execution_simulation(self):
        """Simulate workflow execution"""
        steps = self.config['steps']
        executed_steps = []
        failed_steps = []
        
        for step in steps:
            try:
                # Simulate step execution
                print(f"Executing step: {step['name']}")
                
                # Check dependencies
                if step.get('dependencies'):
                    for dep in step['dependencies']:
                        if dep not in executed_steps:
                            raise Exception(f"Dependency {dep} not met for step {step['name']}")
                
                # Simulate step completion
                executed_steps.append(step['name'])
                print(f"Step {step['name']} completed successfully")
                
            except Exception as e:
                failed_steps.append(step['name'])
                print(f"Step {step['name']} failed: {str(e)}")
                
                # Handle error based on configuration
                if self.config['config']['error_handling'] == 'stop_on_error':
                    break
        
        # Verify execution results
        assert len(executed_steps) == len(steps), f"Expected {len(steps)} steps, executed {len(executed_steps)}"
        assert len(failed_steps) == 0, f"Failed steps: {failed_steps}"
    
    def test_workflow_performance(self):
        """Test workflow performance characteristics"""
        config = self.config['config']
        
        # Test timeout configuration
        assert config['timeout'] == {{ .Timeout }}
        
        # Test concurrency configuration
        assert config['max_concurrency'] == {{ .MaxConcurrency }}
        
        # Test monitoring configuration
        assert config['monitoring'] == {{ .Monitoring }}

def run_workflow_tests():
    """Run all workflow integration tests"""
    print(f"Running integration tests for workflow: {{ .Name }}")
    
    test_instance = {{ .Name }}WorkflowTest()
    
    # Run tests
    test_methods = [
        test_instance.test_workflow_structure,
        test_instance.test_step_dependencies,
        test_instance.test_resource_limits,
        test_instance.test_error_handling,
        test_instance.test_state_persistence,
        test_instance.test_workflow_files_exist,
        test_instance.test_step_templates_exist,
        test_instance.test_workflow_execution_simulation,
        test_instance.test_workflow_performance,
    ]
    
    passed = 0
    failed = 0
    
    for test_method in test_methods:
        try:
            test_method()
            print(f"✅ {test_method.__name__}: PASSED")
            passed += 1
        except Exception as e:
            print(f"❌ {test_method.__name__}: FAILED - {str(e)}")
            failed += 1
    
    print(f"\n=== Test Results ===")
    print(f"Passed: {passed}")
    print(f"Failed: {failed}")
    print(f"Total: {passed + failed}")
    
    return failed == 0

if __name__ == "__main__":
    success = run_workflow_tests()
    sys.exit(0 if success else 1)
